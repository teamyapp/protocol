// @generated by protobuf-ts 2.9.4 with parameter long_type_number
// @generated from protobuf file "teamy/rollout_service.proto" (syntax proto3)
// tslint:disable
import { Empty } from "../google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { AppRolloutType } from "./message/rollout";
import { Rollout } from "./message/rollout";
/**
 * @generated from protobuf message GetRolloutRequest
 */
export interface GetRolloutRequest {
    /**
     * @generated from protobuf field: uint64 rolloutId = 1;
     */
    rolloutId: number;
}
/**
 * @generated from protobuf message GetRolloutResponse
 */
export interface GetRolloutResponse {
    /**
     * @generated from protobuf field: Rollout rollout = 1;
     */
    rollout?: Rollout;
}
/**
 * @generated from protobuf message ListRolloutsRequest
 */
export interface ListRolloutsRequest {
    /**
     * @generated from protobuf field: repeated uint64 rolloutIds = 1;
     */
    rolloutIds: number[];
}
/**
 * @generated from protobuf message ListRolloutsResponse
 */
export interface ListRolloutsResponse {
    /**
     * @generated from protobuf field: repeated Rollout rollouts = 1;
     */
    rollouts: Rollout[];
}
/**
 * @generated from protobuf message CreateAppRolloutRequest
 */
export interface CreateAppRolloutRequest {
    /**
     * @generated from protobuf field: uint64 appId = 1;
     */
    appId: number;
    /**
     * @generated from protobuf field: AppRolloutType type = 2;
     */
    type: AppRolloutType;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: uint64 activatorId = 4;
     */
    activatorId: number;
    /**
     * @generated from protobuf field: uint64 versionSelectorId = 5;
     */
    versionSelectorId: number;
    /**
     * @generated from protobuf field: bool isEnabled = 6;
     */
    isEnabled: boolean;
    /**
     * @generated from protobuf field: repeated uint64 groupIds = 7;
     */
    groupIds: number[];
}
/**
 * @generated from protobuf message CreateAppRolloutResponse
 */
export interface CreateAppRolloutResponse {
    /**
     * @generated from protobuf field: Rollout rollout = 1;
     */
    rollout?: Rollout;
}
/**
 * @generated from protobuf message UpdateRolloutRequest
 */
export interface UpdateRolloutRequest {
    /**
     * @generated from protobuf field: uint64 rolloutId = 1;
     */
    rolloutId: number;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint64 activatorId = 3;
     */
    activatorId?: number;
    /**
     * @generated from protobuf field: optional uint64 versionSelectorId = 4;
     */
    versionSelectorId?: number;
    /**
     * @generated from protobuf field: optional bool isEnabled = 5;
     */
    isEnabled?: boolean;
    /**
     * @generated from protobuf field: repeated uint64 groupIds = 6;
     */
    groupIds: number[];
}
/**
 * @generated from protobuf message UpdateRolloutResponse
 */
export interface UpdateRolloutResponse {
    /**
     * @generated from protobuf field: Rollout rollout = 1;
     */
    rollout?: Rollout;
}
/**
 * @generated from protobuf message DeleteRolloutRequest
 */
export interface DeleteRolloutRequest {
    /**
     * @generated from protobuf field: uint64 rolloutId = 1;
     */
    rolloutId: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetRolloutRequest$Type extends MessageType<GetRolloutRequest> {
    constructor() {
        super("GetRolloutRequest", [
            { no: 1, name: "rolloutId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<GetRolloutRequest>): GetRolloutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rolloutId = 0;
        if (value !== undefined)
            reflectionMergePartial<GetRolloutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolloutRequest): GetRolloutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rolloutId */ 1:
                    message.rolloutId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolloutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rolloutId = 1; */
        if (message.rolloutId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.rolloutId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRolloutRequest
 */
export const GetRolloutRequest = new GetRolloutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRolloutResponse$Type extends MessageType<GetRolloutResponse> {
    constructor() {
        super("GetRolloutResponse", [
            { no: 1, name: "rollout", kind: "message", T: () => Rollout }
        ]);
    }
    create(value?: PartialMessage<GetRolloutResponse>): GetRolloutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetRolloutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRolloutResponse): GetRolloutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Rollout rollout */ 1:
                    message.rollout = Rollout.internalBinaryRead(reader, reader.uint32(), options, message.rollout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRolloutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Rollout rollout = 1; */
        if (message.rollout)
            Rollout.internalBinaryWrite(message.rollout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRolloutResponse
 */
export const GetRolloutResponse = new GetRolloutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRolloutsRequest$Type extends MessageType<ListRolloutsRequest> {
    constructor() {
        super("ListRolloutsRequest", [
            { no: 1, name: "rolloutIds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<ListRolloutsRequest>): ListRolloutsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rolloutIds = [];
        if (value !== undefined)
            reflectionMergePartial<ListRolloutsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRolloutsRequest): ListRolloutsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 rolloutIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rolloutIds.push(reader.uint64().toNumber());
                    else
                        message.rolloutIds.push(reader.uint64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRolloutsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 rolloutIds = 1; */
        if (message.rolloutIds.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rolloutIds.length; i++)
                writer.uint64(message.rolloutIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListRolloutsRequest
 */
export const ListRolloutsRequest = new ListRolloutsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListRolloutsResponse$Type extends MessageType<ListRolloutsResponse> {
    constructor() {
        super("ListRolloutsResponse", [
            { no: 1, name: "rollouts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Rollout }
        ]);
    }
    create(value?: PartialMessage<ListRolloutsResponse>): ListRolloutsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rollouts = [];
        if (value !== undefined)
            reflectionMergePartial<ListRolloutsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRolloutsResponse): ListRolloutsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Rollout rollouts */ 1:
                    message.rollouts.push(Rollout.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRolloutsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Rollout rollouts = 1; */
        for (let i = 0; i < message.rollouts.length; i++)
            Rollout.internalBinaryWrite(message.rollouts[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ListRolloutsResponse
 */
export const ListRolloutsResponse = new ListRolloutsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAppRolloutRequest$Type extends MessageType<CreateAppRolloutRequest> {
    constructor() {
        super("CreateAppRolloutRequest", [
            { no: 1, name: "appId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["AppRolloutType", AppRolloutType, "APP_ROLLOUT_TYPE_"] },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "activatorId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "versionSelectorId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 6, name: "isEnabled", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 7, name: "groupIds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<CreateAppRolloutRequest>): CreateAppRolloutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.appId = 0;
        message.type = 0;
        message.name = "";
        message.activatorId = 0;
        message.versionSelectorId = 0;
        message.isEnabled = false;
        message.groupIds = [];
        if (value !== undefined)
            reflectionMergePartial<CreateAppRolloutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAppRolloutRequest): CreateAppRolloutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 appId */ 1:
                    message.appId = reader.uint64().toNumber();
                    break;
                case /* AppRolloutType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* uint64 activatorId */ 4:
                    message.activatorId = reader.uint64().toNumber();
                    break;
                case /* uint64 versionSelectorId */ 5:
                    message.versionSelectorId = reader.uint64().toNumber();
                    break;
                case /* bool isEnabled */ 6:
                    message.isEnabled = reader.bool();
                    break;
                case /* repeated uint64 groupIds */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.groupIds.push(reader.uint64().toNumber());
                    else
                        message.groupIds.push(reader.uint64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAppRolloutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 appId = 1; */
        if (message.appId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.appId);
        /* AppRolloutType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* uint64 activatorId = 4; */
        if (message.activatorId !== 0)
            writer.tag(4, WireType.Varint).uint64(message.activatorId);
        /* uint64 versionSelectorId = 5; */
        if (message.versionSelectorId !== 0)
            writer.tag(5, WireType.Varint).uint64(message.versionSelectorId);
        /* bool isEnabled = 6; */
        if (message.isEnabled !== false)
            writer.tag(6, WireType.Varint).bool(message.isEnabled);
        /* repeated uint64 groupIds = 7; */
        if (message.groupIds.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.groupIds.length; i++)
                writer.uint64(message.groupIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateAppRolloutRequest
 */
export const CreateAppRolloutRequest = new CreateAppRolloutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateAppRolloutResponse$Type extends MessageType<CreateAppRolloutResponse> {
    constructor() {
        super("CreateAppRolloutResponse", [
            { no: 1, name: "rollout", kind: "message", T: () => Rollout }
        ]);
    }
    create(value?: PartialMessage<CreateAppRolloutResponse>): CreateAppRolloutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateAppRolloutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateAppRolloutResponse): CreateAppRolloutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Rollout rollout */ 1:
                    message.rollout = Rollout.internalBinaryRead(reader, reader.uint32(), options, message.rollout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateAppRolloutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Rollout rollout = 1; */
        if (message.rollout)
            Rollout.internalBinaryWrite(message.rollout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CreateAppRolloutResponse
 */
export const CreateAppRolloutResponse = new CreateAppRolloutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolloutRequest$Type extends MessageType<UpdateRolloutRequest> {
    constructor() {
        super("UpdateRolloutRequest", [
            { no: 1, name: "rolloutId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "activatorId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "versionSelectorId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "isEnabled", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "groupIds", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateRolloutRequest>): UpdateRolloutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rolloutId = 0;
        message.groupIds = [];
        if (value !== undefined)
            reflectionMergePartial<UpdateRolloutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolloutRequest): UpdateRolloutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rolloutId */ 1:
                    message.rolloutId = reader.uint64().toNumber();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint64 activatorId */ 3:
                    message.activatorId = reader.uint64().toNumber();
                    break;
                case /* optional uint64 versionSelectorId */ 4:
                    message.versionSelectorId = reader.uint64().toNumber();
                    break;
                case /* optional bool isEnabled */ 5:
                    message.isEnabled = reader.bool();
                    break;
                case /* repeated uint64 groupIds */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.groupIds.push(reader.uint64().toNumber());
                    else
                        message.groupIds.push(reader.uint64().toNumber());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolloutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rolloutId = 1; */
        if (message.rolloutId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.rolloutId);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional uint64 activatorId = 3; */
        if (message.activatorId !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.activatorId);
        /* optional uint64 versionSelectorId = 4; */
        if (message.versionSelectorId !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.versionSelectorId);
        /* optional bool isEnabled = 5; */
        if (message.isEnabled !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isEnabled);
        /* repeated uint64 groupIds = 6; */
        if (message.groupIds.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.groupIds.length; i++)
                writer.uint64(message.groupIds[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateRolloutRequest
 */
export const UpdateRolloutRequest = new UpdateRolloutRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRolloutResponse$Type extends MessageType<UpdateRolloutResponse> {
    constructor() {
        super("UpdateRolloutResponse", [
            { no: 1, name: "rollout", kind: "message", T: () => Rollout }
        ]);
    }
    create(value?: PartialMessage<UpdateRolloutResponse>): UpdateRolloutResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateRolloutResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRolloutResponse): UpdateRolloutResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Rollout rollout */ 1:
                    message.rollout = Rollout.internalBinaryRead(reader, reader.uint32(), options, message.rollout);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRolloutResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Rollout rollout = 1; */
        if (message.rollout)
            Rollout.internalBinaryWrite(message.rollout, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateRolloutResponse
 */
export const UpdateRolloutResponse = new UpdateRolloutResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteRolloutRequest$Type extends MessageType<DeleteRolloutRequest> {
    constructor() {
        super("DeleteRolloutRequest", [
            { no: 1, name: "rolloutId", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteRolloutRequest>): DeleteRolloutRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rolloutId = 0;
        if (value !== undefined)
            reflectionMergePartial<DeleteRolloutRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteRolloutRequest): DeleteRolloutRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 rolloutId */ 1:
                    message.rolloutId = reader.uint64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteRolloutRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 rolloutId = 1; */
        if (message.rolloutId !== 0)
            writer.tag(1, WireType.Varint).uint64(message.rolloutId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DeleteRolloutRequest
 */
export const DeleteRolloutRequest = new DeleteRolloutRequest$Type();
/**
 * @generated ServiceType for protobuf service RolloutService
 */
export const RolloutService = new ServiceType("RolloutService", [
    { name: "GetRollout", options: {}, I: GetRolloutRequest, O: GetRolloutResponse },
    { name: "ListRollouts", options: {}, I: ListRolloutsRequest, O: ListRolloutsResponse },
    { name: "CreateAppRollout", options: {}, I: CreateAppRolloutRequest, O: CreateAppRolloutResponse },
    { name: "UpdateRollout", options: {}, I: UpdateRolloutRequest, O: UpdateRolloutResponse },
    { name: "DeleteRollout", options: {}, I: DeleteRolloutRequest, O: Empty }
]);
